<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Simple Water Flow Simulation</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <!-- Include Three.js from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Scene, Camera, Renderer
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000); // Black background

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 1000);
      camera.position.z = 100;

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create a particle system to simulate water flow.
      const particleCount = 1000;
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);

      // Initialize particles
      for (let i = 0; i < particleCount; i++) {
          // Random initial positions spread across a volume.
          positions[i * 3]     = (Math.random() - 0.5) * 200;  // x
          positions[i * 3 + 1] = (Math.random() - 0.5) * 200;  // y
          positions[i * 3 + 2] = (Math.random() - 0.5) * 200;  // z

          // Velocities with a dominant flow along +x (and slight randomness)
          velocities[i * 3]     = 0.5 + (Math.random() - 0.5) * 0.1;
          velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.2;
          velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      // Create a material for blueish, semi-transparent particles.
      const material = new THREE.PointsMaterial({
          color: 0x3399ff,     // Blueish color
          size: 2,
          transparent: true,
          opacity: 0.8
      });

      // Create the particle system and add it to the scene.
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // Animation loop: update particle positions.
      function animate() {
          requestAnimationFrame(animate);
          const positions = geometry.attributes.position.array;
          for (let i = 0; i < particleCount; i++) {
              positions[i * 3]     += velocities[i * 3];
              positions[i * 3 + 1] += velocities[i * 3 + 1];
              positions[i * 3 + 2] += velocities[i * 3 + 2];

              // Wrap-around: if a particle flows beyond x = 100, send it back to x = -100.
              if (positions[i * 3] > 100) {
                  positions[i * 3] = -100;
                  // Optionally re-randomize y and z to vary the flow
                  positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
                  positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
              }
          }
          geometry.attributes.position.needsUpdate = true;
          renderer.render(scene, camera);
      }
      animate();

      // Handle browser resize events.
      window.addEventListener('resize', () => {
          const width = window.innerWidth;
          const height = window.innerHeight;
          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
