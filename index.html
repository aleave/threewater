<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Real-Time Earthquake Globe</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; }
  </style>
</head>
<body>
  <!-- Load Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Optionally, include OrbitControls for debugging (commented out for production) -->
  <!-- <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script> -->
  <script>
    let scene, camera, renderer;
    let earthMesh, quakeGroup;
    const EARTH_RADIUS = 3;
    
    init();
    animate();
    fetchEarthquakeData(); // initial fetch
    // Update quake markers every 60 seconds (60000 ms)
    setInterval(fetchEarthquakeData, 60000);

    // Initialize the scene, camera, lights, Earth, etc.
    function init() {
      // Create scene
      scene = new THREE.Scene();
      
      // Create camera: perspective camera with FOV=75, near=0.1, far=1000
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 10);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add ambient and directional lights for the Earth
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 3, 5);
      scene.add(directionalLight);
      
      // Create Earth geometry and load texture
      const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
      const textureLoader = new THREE.TextureLoader();
      // You can use any Earth texture image you like; this one is from Three.js examples.
      const earthTexture = textureLoader.load("https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg");
      const earthMaterial = new THREE.MeshPhongMaterial({
        map: earthTexture,
        transparent: true,
        opacity: 0.8
      });
      earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earthMesh);
      
      // Create a group to hold quake markers.
      quakeGroup = new THREE.Group();
      scene.add(quakeGroup);
      
      // Listen to window resize events.
      window.addEventListener('resize', onWindowResize, false);
      
      // Optional: if you want to orbit around the Earth for debugging
      // const controls = new THREE.OrbitControls(camera, renderer.domElement);
    }

    // Adjust camera and renderer when window size changes.
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Convert latitude and longitude (in degrees) to a 3D vector on a sphere.
    // 'radius' is the base radius, and 'height' is an optional offset (so markers sit above the surface).
    function latLongToVector3(lat, lon, radius, height = 0) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);
      
      const r = radius + height;
      const x = -r * Math.sin(phi) * Math.cos(theta);
      const z = r * Math.sin(phi) * Math.sin(theta);
      const y = r * Math.cos(phi);
      
      return new THREE.Vector3(x, y, z);
    }
    
    // Fetch earthquake data from the USGS API and update quake markers.
    function fetchEarthquakeData() {
      // USGS query URL: limit=20, within given lat/lon bounds (continental US), ordered by time.
      const queryUrl = "https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson" +
                       "&limit=20" +
                       "&minlatitude=21.9838&maxlatitude=51.78144" +
                       "&minlongitude=-130.16602&maxlongitude=-59.85352" +
                       "&orderby=time";
      
      fetch(queryUrl)
        .then(response => response.json())
        .then(data => {
          updateQuakeMarkers(data);
        })
        .catch(error => console.error("Error fetching earthquake data:", error));
    }
    
    // Remove old markers and add new ones based on the fetched data.
    function updateQuakeMarkers(data) {
      // Clear old markers
      while (quakeGroup.children.length) {
        quakeGroup.remove(quakeGroup.children[0]);
      }
      
      // For each earthquake, create a marker.
      data.features.forEach(feature => {
        const mag = feature.properties.mag;
        const coords = feature.geometry.coordinates; // [longitude, latitude, depth]
        const lon = coords[0];
        const lat = coords[1];
        
        // Set marker size proportional to magnitude.
        // Use a base scale factor and enforce a minimum size.
        const markerSize = Math.max(0.05, mag * 0.1);
        const markerGeometry = new THREE.SphereGeometry(markerSize, 16, 16);
        const markerMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.7
        });
        const markerMesh = new THREE.Mesh(markerGeometry, markerMaterial);
        
        // Convert lat/lon to 3D position.
        // Place the marker slightly above the Earth's surface (height offset = 0.1).
        markerMesh.position.copy(latLongToVector3(lat, lon, EARTH_RADIUS, 0.1));
        
        quakeGroup.add(markerMesh);
      });
    }
    
    // Animation loop: slowly rotate the Earth and render the scene.
    function animate() {
      requestAnimationFrame(animate);
      
      // Slowly rotate the Earth on its Y-axis.
      earthMesh.rotation.y += 0.001;
      
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
