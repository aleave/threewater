<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Smooth Pulsating Blob</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; }
  </style>
</head>
<body>
  <!-- Load Three.js from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, mesh, geometry, clock;
    let basePositions, vertexPhases, vertexFreqs;

    init();
    animate();

    function init() {
      // Create the scene with a black background.
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // Set up the perspective camera.
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 10;

      // Initialize the WebGL renderer.
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create a sphere geometry with fewer segments to reduce the number of wireframe lines.
      // This still provides enough detail for a smooth pulsation.
      geometry = new THREE.SphereBufferGeometry(3, 32, 32);

      // Use a translucent wireframe material for a softer look.
      const material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        wireframe: true,
        transparent: true,
        opacity: 0.5
      });

      // Create the mesh and add it to the scene.
      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      // Store the original positions for each vertex.
      const positionAttribute = geometry.attributes.position;
      const vertexCount = positionAttribute.count;
      basePositions = new Float32Array(positionAttribute.array);

      // Assign a random phase and frequency to each vertex for individual pulsation.
      vertexPhases = new Float32Array(vertexCount);
      vertexFreqs = new Float32Array(vertexCount);
      for (let i = 0; i < vertexCount; i++) {
        vertexPhases[i] = Math.random() * Math.PI * 2;
        vertexFreqs[i] = 0.5 + Math.random(); // frequencies between 0.5 and 1.5
      }

      // Create a clock to track elapsed time.
      clock = new THREE.Clock();

      // Adjust rendering on window resize.
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const time = clock.getElapsedTime();

      const positions = geometry.attributes.position.array;
      const vertexCount = geometry.attributes.position.count;

      // Update each vertex's position.
      for (let i = 0; i < vertexCount; i++) {
        const ix = i * 3;
        const bx = basePositions[ix];
        const by = basePositions[ix + 1];
        const bz = basePositions[ix + 2];

        // Compute the original radius.
        const originalRadius = Math.sqrt(bx * bx + by * by + bz * bz);

        // Use a reduced amplitude (0.2 instead of 0.5) for a softer pulsation.
        const displacement = 0.2 * Math.sin(time * vertexFreqs[i] + vertexPhases[i]);

        const newRadius = originalRadius + displacement;

        // Scale the original base position to get the new position.
        const factor = newRadius / originalRadius;
        positions[ix]     = bx * factor;
        positions[ix + 1] = by * factor;
        positions[ix + 2] = bz * factor;
      }
      geometry.attributes.position.needsUpdate = true;

      // Optionally, rotate the blob slowly for additional dynamism.
      mesh.rotation.y += 0.005;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
