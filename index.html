<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pulsating Blob Visualization</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; }
  </style>
</head>
<body>
  <!-- Load Three.js from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, mesh, geometry, clock;
    let basePositions, vertexPhases, vertexFreqs;

    init();
    animate();

    function init() {
      // Create the scene and set a black background.
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // Set up a perspective camera.
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 10;

      // Initialize the WebGL renderer.
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create a smooth sphere geometry.
      // Increasing the width and height segments makes the blob smoother.
      geometry = new THREE.SphereBufferGeometry(3, 64, 64);

      // Use a basic material in wireframe mode for a minimalist look.
      const material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        wireframe: true,
      });

      // Create the mesh and add it to the scene.
      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      // Store the original positions of each vertex so we know the base shape.
      const positionAttribute = geometry.attributes.position;
      const vertexCount = positionAttribute.count;
      basePositions = new Float32Array(positionAttribute.array); // deep copy

      // For each vertex, assign a random phase and frequency to drive the pulsation.
      vertexPhases = new Float32Array(vertexCount);
      vertexFreqs = new Float32Array(vertexCount);
      for (let i = 0; i < vertexCount; i++) {
        vertexPhases[i] = Math.random() * Math.PI * 2;
        vertexFreqs[i] = 0.5 + Math.random(); // frequencies between 0.5 and 1.5
      }

      // Create a clock to track elapsed time.
      clock = new THREE.Clock();

      // Adjust rendering on window resize.
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const time = clock.getElapsedTime();

      const positions = geometry.attributes.position.array;
      const vertexCount = geometry.attributes.position.count;

      // Update each vertex's position.
      for (let i = 0; i < vertexCount; i++) {
        const ix = i * 3;
        const bx = basePositions[ix];
        const by = basePositions[ix + 1];
        const bz = basePositions[ix + 2];

        // Calculate the original radius (distance from the center).
        const originalRadius = Math.sqrt(bx * bx + by * by + bz * bz);

        // Compute a displacement based on a sine wave with a random phase and frequency.
        const displacement = 0.5 * Math.sin(time * vertexFreqs[i] + vertexPhases[i]);

        // The new radius is the original radius plus the computed displacement.
        const newRadius = originalRadius + displacement;

        // Normalize the original base position and scale it by the new radius.
        const factor = newRadius / originalRadius;
        positions[ix]     = bx * factor;
        positions[ix + 1] = by * factor;
        positions[ix + 2] = bz * factor;
      }
      geometry.attributes.position.needsUpdate = true;

      // Optionally, rotate the whole blob for an additional dynamic effect.
      mesh.rotation.y += 0.005;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
